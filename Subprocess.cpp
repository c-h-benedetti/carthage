#include <iostream>
#include <fstream>
#include <queue>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <string>
#include <thread>
#include <cstring>
#include <vector>
#include <sys/stat.h>
#include "utils.hpp"
#include "Subprocess.hpp"
#include "signals.h"

void Subprocess::set_state(Subprocess::State s){
  this->state = s;

  switch(s){
    case(State::INVALID):
      break;

    case(State::RUNNING):
      break;

    case(State::FINISHED):
      if (this->pid){
        this->is_over();
        this->log_file.close();
      }
      break;

    case(State::DESTROYED):
      if (this->pid){
        this->is_over();
        this->log_file.close();
      }
      break;

    case(State::INITIALIZED):
      break;
  };

  for(auto func : this->subscribers){
    func(this->state);
  }
}

void Subprocess::subscribe_to(const std::function<void(Subprocess::State)>& f){
  this->subscribers.push_back(f);
}

// Launching thread waiting for the end of the process generated by the fork
int Subprocess::thread_is_done(){
  this->thread_is_alive = std::thread(wait_for_subprocess, (Subprocess*)this, this->pid);
  return 0;
}

// Launching the thread that loops on read() to listen the pipe from the subprocess
int Subprocess::thread_listen_pipe(){
  this->thread_listener = std::thread(listen_to_pipe, (Subprocess*)this, this->file_descriptors[PIPE_OUTPUT], &this->log_file, &this->process_name);
  return 0;
}

// Overlay the forked process (child side) with another executable
// Useless to have handles on it since it will be overwritten
int Subprocess::overlay(){
  // The arguments array must begin by the command itself (the same used to launch the process) and must end with NULL
  // So we need 2 more slots than the arguments size
  char* args[this->command_line_args.size()+2] = {0};
  args[0] = (char*)this->command.c_str();

  // Copying arguments to array passed to the execvp
  for(uint i = 1 ; i < this->command_line_args.size()+1 ; i++){
    args[i] = (char*)this->command_line_args[i-1].c_str();
  }
  
  // Trying to overlay the forked process
  if (execvp(args[0], args) == -1){
    args[0] = (char*)this->_command_.c_str(); // We failed, we try to use the emergency command
    std::cerr << "Failed to overlay with main command while launching: " + this->process_name << ". Trying with \"" + this->_command_ + "\"" << std::endl;
    
    if (execvp(args[0], args) == -1){
      std::cerr << "Failed to overlay emergency command: " + this->process_name << std::endl;
    }

    std::cerr << "Failed to overlay process while launching: " + this->process_name << std::endl;
    return PStatus::FAILED_OVERLAY;
  }

  return PStatus::SUCCESS;
}

// The process is finished, we want to join the threads inspecting the subprocess
void Subprocess::is_over(){
  if (this->state != State::FINISHED){
    if (this->thread_is_alive.joinable()){
      this->thread_is_alive.join();
    }
    else{
      std::cerr << "Failed to join thread [thread_is_alive] (Maybe never launched?)" << std::endl;
    }
    if (this->thread_listener.joinable()){
      this->thread_listener.join();
    }
    else{
      std::cerr << "Failed to join thread [thread_listener] (Maybe never launched?)" << std::endl;
    }
    this->pid = 0;
  }
}


int Subprocess::launch(){

  if (this->state != State::INITIALIZED){
    std::cerr << "Unable to call launch() on this Subprocess object" << std::endl;
    return -1;
  }

  this->secure_log_path();

  // Creating the pipe to communicate with sub process
  if (pipe(this->file_descriptors) == -1){
    std::cerr << "Failed to create the pipe while launching: " + this->process_name << std::endl;
    return PStatus::FAILED_PIPE;
  }

  // Forking current process
  if ((this->pid = fork()) == -1){
    // If the fork fails, we don't need to communicate with anything process
    close(this->file_descriptors[PIPE_OUTPUT]);
    close(this->file_descriptors[PIPE_INPUT]);
    std::cerr << "Failed to fork current process while launching: " + this->process_name << std::endl;
    return PStatus::FAILED_FORK;
  }

  if (this->pid){
    // We are in the parent process
    close(this->file_descriptors[PIPE_INPUT]); // We are not interested in writting to the sub process, we just wanna listen
    this->log_file = std::ofstream(this->log_file_path); // We also wanna collect outputs from the process in a log file by subprocess

    this->thread_is_done(); // Waiting for the subprocess to come to its end
    this->thread_listen_pipe(); // Listening outputs from subprocess
    this->set_state(State::RUNNING); // At this point, the subprocess is fully running

    return PStatus::SUCCESS;
  }
  else{
    // We are in the child process

    // The same descriptor must not be shared by different processes
    // To avoid that, we make 2 new descriptors pointing to the same file (to avoid conflicts while accessing the file)
    dup2(this->file_descriptors[PIPE_INPUT], STDOUT_FILENO); // All cout will be sent to us
    dup2(this->file_descriptors[PIPE_INPUT], STDERR_FILENO); // All cerr will be sent to us

    close(this->file_descriptors[PIPE_OUTPUT]); // dup2 cloned descriptors, so we don't need originals ones anymore
    close(this->file_descriptors[PIPE_INPUT]);

    std::cerr << "Pipe created successfully !!!" << std::endl; // First line of every log file

    if (this->overlay()){
      // If overlaying failed, we don't further in the child code
      return PStatus::FAILED_OVERLAY;
    }
    // If overlaying is successful, execution stops here in the child
    // Will never pass in this block, just to remove warning from compiler
    else{
      return PStatus::SUCCESS;
    }
  }
}

void Subprocess::terminate(){
  if (this->state == State::RUNNING){
    if (!kill(this->pid, SIGTERM)){
      kill(this->pid, SIGKILL);
    }
    this->set_state(State::FINISHED);
  }
}

Subprocess::State Subprocess::get_state() const{
  return this->state;
}

Subprocess::Subprocess(
  std::string cmd, 
  std::vector<std::string> args, 
  std::string log_path, 
  std::string p_name
) : command(cmd), command_line_args(args), log_file_path(log_path), process_name(p_name){
  this->set_state(State::INITIALIZED);
}

Subprocess::~Subprocess(){
  this->set_state(State::DESTROYED);
}


int Subprocess::get_return_status() const{
  return this->return_status;
}

void Subprocess::secure_log_path(){
  if (this->log_file_path.size() == 0){
    std::cerr << "Log file path shouldn't be left empty" << std::endl;
    this->log_file_path = "/tmp/log_subprocess.log";
  }
}

void wait_for_subprocess(Subprocess* s, pid_t pid){
  int status = 0;
  waitpid(pid, &status, 0);
  s->set_state(Subprocess::State::FINISHED);

  if (!WIFEXITED(status)){
    printf("Process %d didn't end up correctly\n", pid);
    if (WIFSIGNALED(status)){
      printf("Process %d ended up because of an unhandled signal: %s\n", pid, signals[WTERMSIG(status)].c_str());
    }
  }
  else{
    printf("Process %d finished correctly with status code %d\n", pid, WEXITSTATUS(status));
  }

  s->return_status = status;
}

void check_for_message(int fd_read, std::ofstream* o, std::string* command){
  size_t size_buf = 8192;
  char buffer[size_buf] = {0};
  size_t r = read(fd_read, buffer, size_buf);
  char* mark = strtok(buffer, "\n");

  if (r > 0){
    while(mark){
      std::cerr << "$(" << command->c_str() << ") " << mark << std::endl;
      (*o) << mark << std::endl;
      mark = strtok(NULL, "\n");
    }
  }
}

void listen_to_pipe(Subprocess* s, int fd_read, std::ofstream* o, std::string* command){
  forever{
    check_for_message(fd_read, o, command);
    if (s->state != Subprocess::State::RUNNING){
      close(fd_read);
      break;
    }
  }
}

